#include "game_fallout4/fallout4gameplugins.h"

#include <QDir>
#include <QStringList>
#include <QTextCodec>
#include <uibase/ipluginlist.h>
#include <uibase/report.h>
#include <uibase/safewritefile.h>
#include <uibase/scopeguard.h>

using MOBase::IOrganizer;
using MOBase::IPluginGame;
using MOBase::IPluginList;
using MOBase::SafeWriteFile;
using MOBase::reportError;

static const std::set<QString> OFFICIAL_FILES{"Fallout4.esm",    "DLCRobot.esm",      "DLCworkshop01.esm",
                                              "DLCCoast.esm",    "DLCworkshop02.esm", "DLCworkshop03.esm",
                                              "DLCNukaWorld.esm"};

Fallout4GamePlugins::Fallout4GamePlugins(IOrganizer* organizer) : GamebryoGamePlugins(organizer) {}

void Fallout4GamePlugins::writePluginList(const IPluginList* pluginList, const QString& filePath) {
    SafeWriteFile file(filePath);

    QTextCodec* textCodec = localCodec();

    file->resize(0);

    file->write(textCodec->fromUnicode("# This file was automatically generated by Mod Organizer.\r\n"));

    bool invalidFileNames = false;
    int writtenCount = 0;

    QStringList plugins = pluginList->pluginNames();
    std::sort(plugins.begin(), plugins.end(), [pluginList](const QString& lhs, const QString& rhs) {
        return pluginList->priority(lhs) < pluginList->priority(rhs);
    });

    QStringList PrimaryPlugins = organizer()->managedGame()->primaryPlugins();

    for (auto f : OFFICIAL_FILES) {
        if (!PrimaryPlugins.contains(f, Qt::CaseInsensitive)) {
            PrimaryPlugins.append(f);
        }
    }

    // TODO: do not write plugins in OFFICIAL_FILES container
    for (const QString& pluginName : plugins) {
        if (!PrimaryPlugins.contains(pluginName, Qt::CaseInsensitive)) {
            if (pluginList->state(pluginName) == IPluginList::STATE_ACTIVE) {
                if (!textCodec->canEncode(pluginName)) {
                    invalidFileNames = true;
                    qCritical("invalid plugin name %s", qPrintable(pluginName));
                } else {
                    file->write("*");
                    file->write(textCodec->fromUnicode(pluginName));
                }
                file->write("\r\n");
                ++writtenCount;
            } else {
                if (!textCodec->canEncode(pluginName)) {
                    invalidFileNames = true;
                    qCritical("invalid plugin name %s", qPrintable(pluginName));
                } else {
                    file->write(textCodec->fromUnicode(pluginName));
                }
                file->write("\r\n");
                ++writtenCount;
            }
        }
    }

    if (invalidFileNames) {
        reportError(QObject::tr("Some of your plugins have invalid names! These "
                                "plugins can not be loaded by the game. Please see "
                                "mo_interface.log for a list of affected plugins "
                                "and rename them."));
    }

    if (file.commitIfDifferent(m_LastSaveHash[filePath])) {
        qDebug("%s saved", qPrintable(QDir::toNativeSeparators(filePath)));
    }
}

bool Fallout4GamePlugins::readPluginList(MOBase::IPluginList* pluginList, const QString& filePath, bool useLoadOrder) {
    QStringList plugins = pluginList->pluginNames();
    QStringList loadOrder = organizer()->managedGame()->primaryPlugins();

    for (auto f : OFFICIAL_FILES) {
        if (!loadOrder.contains(f, Qt::CaseInsensitive)) {
            loadOrder.append(f);
        }
    }

    for (const QString& pluginName : loadOrder) {
        if (pluginList->state(pluginName) != IPluginList::STATE_MISSING) {
            pluginList->setState(pluginName, IPluginList::STATE_ACTIVE);
            plugins.removeAll(pluginName);
        }
    }

    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        qWarning("%s not found", qPrintable(filePath));
        return false;
    }
    ON_BLOCK_EXIT([&]() { file.close(); });

    if (file.size() == 0) {
        // MO stores at least a header in the file. if it's completely empty the
        // file is broken
        qWarning("%s empty", qPrintable(filePath));
        return false;
    }

    while (!file.atEnd()) {
        QByteArray line = file.readLine();
        QString pluginName;
        if ((line.size() > 0) && (line.at(0) != '#')) {
            pluginName = localCodec()->toUnicode(line.trimmed().constData());
        }
        if (pluginName.startsWith('*')) {
            pluginName.remove(0, 1);
            if (pluginName.size() > 0) {
                pluginList->setState(pluginName, IPluginList::STATE_ACTIVE);
                plugins.removeAll(pluginName);
                if (!loadOrder.contains(pluginName, Qt::CaseInsensitive)) {
                    loadOrder.append(pluginName);
                }
            }
        } else {
            if (pluginName.size() > 0) {
                pluginList->setState(pluginName, IPluginList::STATE_INACTIVE);
                plugins.removeAll(pluginName);
                if (!loadOrder.contains(pluginName, Qt::CaseInsensitive)) {
                    loadOrder.append(pluginName);
                }
            }
        }
    }

    file.close();

    // we removed each plugin found in the file, so what's left are inactive mods
    for (const QString& pluginName : plugins) {
        pluginList->setState(pluginName, IPluginList::STATE_INACTIVE);
    }

    if (useLoadOrder) {
        pluginList->setLoadOrder(loadOrder);
    }

    return true;
}
